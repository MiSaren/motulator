"""
3-phase AC voltage source models.

Peak-valued complex space vectors are used.

"""
from types import SimpleNamespace

import numpy as np

from motulator.common.model import Subsystem
from motulator.common.utils._utils import (complex2abc, abc2complex, wrap)

# %%
# TODO: implement simulation of harmonics, nonsymmetric faults
class StiffSource(Subsystem):
    """
    3-phase voltage source model.

    This model is a 3-phase voltage source for the AC grid. A stiff grid is
    modeled, where the frequency is given by the user either as a constant
    or time-dependent function. Grid voltage magnitude can also be a function,
    to simulate voltage dips and symmetrical short circuits. The complex form
    of the grid angle (exp_j_theta_g) is used as a state variable.

    Parameters
    ----------
    w_gN : float
        Grid nominal frequency (rad/s).
    e_g_abs : float | callable
        3-phase grid voltage magnitude, phase-to-ground peak value (V).
    w_g : callable, optional
        Grid frequency (rad/s) as a function of time, `w_g(t)`. If given, w_g
        will be used to compute grid voltage angle instead of w_N. The default
        value is None.

    """

    def __init__(self, w_gN, e_g_abs, w_g=None):
        super().__init__()
        self.w_g=w_g
        self.par = SimpleNamespace(w_gN=w_gN, e_g_abs=e_g_abs)
        # states
        self.state = SimpleNamespace(exp_j_theta_g=complex(1))
        # Store the solutions in these lists
        self.sol_states = SimpleNamespace(exp_j_theta_g=[])

    def voltages(self, t, theta_g):
        """
        Compute the grid voltage in stationary frame.
           
        Parameters
        ----------
        t : float
            Time (s).
        theta_g : float
            Grid voltage angle (rad).

        Returns
        -------
        e_gs: complex
            Grid complex voltage (V).

        """

        # Calculation of the three-phase voltages
        e_g_abs = self.par.e_g_abs(t) if callable(
            self.par.e_g_abs) else self.par.e_g_abs
        e_g_a = e_g_abs*np.cos(theta_g)
        e_g_b = e_g_abs*np.cos(theta_g-2*np.pi/3)
        e_g_c = e_g_abs*np.cos(theta_g-4*np.pi/3)

        e_gs = abc2complex([e_g_a, e_g_b, e_g_c])
        return e_gs

    def set_outputs(self, t):
        """Set output variables."""
        self.out.e_gs = self.voltages(t, np.angle(self.state.exp_j_theta_g))

    def set_inputs(self, t):
        """Set input variables."""
        self.inp.w_g = self.w_g(t) if callable(self.w_g) else self.par.w_gN

    def rhs(self):
        """
        Compute the state derivatives.
        
        Returns
        -------
        Complex list, length 1
            Time derivative of the complex state vector, [d_exp_j_theta_g].
            
        """
        d_exp_j_theta_g = 1j*self.inp.w_g*self.state.exp_j_theta_g
        return [d_exp_j_theta_g]

    def meas_voltages(self, t):
        """
        Measure the grid phase voltages.
        
        Parameters
        ----------
        t : float
            Time (s).

        Returns
        -------
        e_g_abc : 3-tuple of floats
            Phase voltages (V).

        """
        e_g_abc = complex2abc(self.voltages(t, np.angle(self.state.exp_j_theta_g)))
        return e_g_abc

    def post_process_states(self):
        """Post-process the solution."""
        if callable(self.w_g):
            self.data.w_g = self.w_g(self.data.t)
        else:
            self.data.w_g = np.full(np.size(self.data.t), self.par.w_gN)
        self.data.theta_g = np.angle(self.data.exp_j_theta_g)
        self.data.e_gs=self.voltages(self.data.t, self.data.theta_g)


class FlexSource(Subsystem):
    """
    3-phase AC grid including synchronous generator electromechanical dynamics.

    This models the 3-phase voltage source of the AC grid while taking into
    account the electromechanical dynamics of a typical grid generated by the 
    synchronous generators. More information about the model can be found in
    [#ENT2013]_.
    
    Parameters
    ----------
    w_gN : float
        Grid nominal frequency (rad/s).
    e_g_abs : float | callable
        3-phase grid voltage magnitude, phase-to-ground peak value (V).
    S_grid : float
        Grid rated power (VA).
    T_D : float, optional
        Turbine delay time constant (s). Default is 10.
    T_N : float, optional
        Turbine derivative time constant (s). Default is 3.
    H_g : float, optional
        Grid inertia constant (s). Default is 3.
    r_d : float, optional
        Primary frequency droop control gain (p.u.). Default is 0.05.
    T_gov : float, optional
        Governor time constant (s). Default is 0.5.
    p_m_ref : callable, optional
        Mechanical power output reference (W). Default is 0.
    p_e : callable, optional
        Electrical power disturbance (W). Default is 0.

    References
    ----------
    .. [#ENT2013] ENTSO-E, Documentation on Controller Tests in Test Grid
        Configurations, Technical Report, 26.11.2013.
    
    """

    def __init__(self, w_gN, e_g_abs, S_grid, T_D=10, T_N=3, H_g=3, D_g=0,
                 r_d=.05, T_gov=0.5, p_m_ref=lambda t: 0, p_e=lambda t: 0):
        super().__init__()
        self.p_m_ref = p_m_ref
        self.p_e = p_e
        self.par = SimpleNamespace(T_D=T_D, T_N=T_N, H_g=H_g, D_g=D_g,
                                   r_d=r_d*w_gN/S_grid, T_gov=T_gov, w_gN=w_gN,
                                   S_grid=S_grid, e_g_abs=e_g_abs)
        # States
        self.state = SimpleNamespace(err_w_g=0, p_gov=0, x_turb=0,
                                     theta_g=0)
        # Store the solutions in these lists
        self.sol_states = SimpleNamespace(err_w_g=[], p_gov=[],
                                          x_turb=[], theta_g=[])

    def voltages(self, t, theta_g):
        """
        Compute the grid voltage in stationary frame:
           
        Parameters
        ----------
        t : float
            Time.
        theta_g : float
            Grid electrical angle (rad).

        Returns
        -------
        e_gs: complex
            Grid complex voltage (V).

        """

        # Calculation of the three-phase voltages
        e_g_abs = self.par.e_g_abs(t) if callable(
            self.par.e_g_abs) else self.par.e_g_abs
        e_g_a = e_g_abs*np.cos(theta_g)
        e_g_b = e_g_abs*np.cos(theta_g-2*np.pi/3)
        e_g_c = e_g_abs*np.cos(theta_g-4*np.pi/3)

        e_gs = abc2complex([e_g_a, e_g_b, e_g_c])
        return e_gs

    def set_outputs(self, t):
        """Set output variables."""
        self.out.e_gs = self.voltages(t, wrap(self.state.theta_g.real))

    def set_inputs(self, t):
        """Set input variables."""
        self.inp.p_m_ref = self.p_m_ref(t)
        self.inp.p_e = self.p_e(t)

    def rhs(self):
        """
        Compute the state derivatives.

        Returns
        -------
        Complex list, length 4
            Time derivative of the complex state vector,
            [d_err_w_g, d_p_gov, d_x_turb, d_theta_g].

        """
        par, state, inp = self.par, self.state, self.inp
        err_w_g = state.err_w_g
        p_gov = state.p_gov
        x_turb = state.x_turb

        # calculation of mechanical power from the turbine output
        p_m = (par.T_N/par.T_D)*p_gov + (1 - (par.T_N/par.T_D))*x_turb
        # swing equation
        p_diff = (p_m - inp.p_e)/par.S_grid # in per units
        d_err_w_g = par.w_gN*(p_diff - par.D_g*err_w_g)/(2*par.H_g)
        # governor dynamics
        d_p_gov = (inp.p_m_ref - (1/par.r_d)*err_w_g - p_gov)/par.T_gov
        # turbine dynamics (lead-lag)
        d_x_turb = (p_gov - x_turb)/par.T_D
        # integration of the angle
        d_theta_g = par.w_gN + err_w_g
        return [d_err_w_g, d_p_gov, d_x_turb, d_theta_g]

    def meas_voltages(self, t):
        """
        Measure the grid phase voltages.
        
        Parameters
        ----------
        t : float
            Time (s).

        Returns
        -------
        e_g_abc : 3-tuple of floats
            Phase voltages (V).

        """
        e_g_abc = complex2abc(self.voltages(t, self.state.theta_g.real))
        return e_g_abc

    def meas_freq(self):
        """
        Measure the grid frequency.

        Returns
        -------
        w_g : float
            Grid angular frequency (rad/s).

        """
        w_g = self.par.w_gN + self.state.err_w_g.real
        return w_g

    def meas_angle(self):
        """
        Measure the grid angle.

        Returns
        -------
        theta_g : float
            Grid electrical angle (rad).

        """
        theta_g = wrap(self.state.theta_g.real)
        return theta_g

    def post_process_states(self):
        """Post-process the solution."""
        self.data.w_g = self.par.w_gN + self.data.err_w_g.real
        self.data.theta_g = wrap(self.data.theta_g.real)
        self.data.e_gs=self.voltages(self.data.t, self.data.theta_g)
